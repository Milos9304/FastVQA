#define _USE_MATH_DEFINES
#include <cmath>

#include "aqc_pqc/AqcPqcAccelerator.h"
#include <nlopt.h>
#include <iostream>

namespace FastVQA{

<<<<<<< HEAD
	double ineq_constraint_trivial(unsigned n, const double *x, double *grad, void *data){
=======
typedef struct {
		Eigen::Vector<qreal, Eigen::Dynamic> *Q;
	    Eigen::Matrix<qreal, Eigen::Dynamic, Eigen::Dynamic>* A;

	    int num_steps;
} OptData;

typedef struct {
	std::vector<std::shared_ptr<Parameter>> *parameters;
	AqcPqcAccelerator *acc;
	PauliHamiltonian *h;
	OptData *optData;

	bool printConstraint;
	double outConstraint;
} ConstrData;

double ineq_constraint_trivial(unsigned n, const double *x, double *grad, void *data){
>>>>>>> main

		ConstrData_trivial *d = (ConstrData_trivial *) data;
		Eigen::Matrix<qreal, Eigen::Dynamic, Eigen::Dynamic> H(d->parameters->size(), d->parameters->size());

		Eigen::Vector<qreal, Eigen::Dynamic> res_eps(n);

		for(unsigned int i = 0; i < n; ++i){
			res_eps(i)=x[i];
			(*d->parameters)[i]->value += res_eps[i];
		}

		for(unsigned int i = 0; i < d->parameters->size(); ++i){

			qreal original_i = (*d->parameters)[i]->value;

			for(unsigned int j = 0; j <= i; ++j){

				qreal original_j = (*d->parameters)[j]->value;

				(*d->parameters)[i]->value += PI_2;
				(*d->parameters)[j]->value += PI_2;

				qreal a = d->acc->_calc_expectation(d->h);

				(*d->parameters)[j]->value -= PI;
				qreal b = d->acc->_calc_expectation(d->h);

				(*d->parameters)[i]->value -= PI;
				(*d->parameters)[j]->value += PI;
				qreal c = d->acc->_calc_expectation(d->h);

				(*d->parameters)[j]->value -= PI;
				qreal dd = d->acc->_calc_expectation(d->h);

				(*d->parameters)[i]->value = original_i;
				(*d->parameters)[j]->value = original_j;

				H(i,j) = 0.25 * (a-b-c+dd);

				if(i != j)
					H(j,i) = H(i,j);
			}
		}

		for(unsigned int i = 0; i < d->parameters->size(); ++i){
			(*d->parameters)[i]->value -= res_eps[i];
		}


		Eigen::SelfAdjointEigenSolver<Eigen::Matrix<qreal, Eigen::Dynamic, Eigen::Dynamic>> solver(H.rows());
		solver.compute(H);
		Eigen::Vector<qreal, Eigen::Dynamic> lambda = solver.eigenvalues().reverse();
		auto X = solver.eigenvalues();

		//std::cerr<<"pass: "<<X.col(0)[0]<<"\n";
		//std::cerr<<"min eval: "<<X.col(0)[0]<<"\n";

		if (grad) {

			Eigen::Vector<qreal, Eigen::Dynamic> e_vect = solver.eigenvectors().col(0);

			for(unsigned int p = 0; p < d->parameters->size(); ++p){

				double e0_p = 0;

				for(int i = 0; i < d->parameters->size(); ++i){ //num rows of Hessian H
					double e0_Aip = e_vect(i)*e_vect(p);
					e0_p += 2*e0_Aip * d->acc->calc_third_derivative(i,p,p,d);//* Aip_p;

					//the above becomes factor of two above
					//double e0_Api = e0_Aip;
					//e0_p += e0_Api * Api_p;
				}

				grad[p] = e0_p;
				std::cerr << "grad_"<<p<<"="<<e0_p<<std::endl;
			}

		}

		if(d->printConstraint)
			d->outConstraint = X.col(0)[0];

		return -X.col(0)[0];//pass?-1:1;
	}

	double lin_system_f_trivial(unsigned n, const double *z, double *grad, void *data){
<<<<<<< HEAD
			OptData_trivial *dt = (OptData_trivial *) data;
=======
			OptData *dt = (OptData *) data;
			dt->num_steps++;
>>>>>>> main

			Eigen::Vector<qreal, Eigen::Dynamic> z_vect(n);
			for(unsigned int i = 0; i < n; ++i)
				z_vect(i)=z[i];
			
			Eigen::Vector<qreal, Eigen::Dynamic> x = *(dt->Q)+*(dt->A)*z_vect;
			Eigen::Matrix<qreal, Eigen::Dynamic, Eigen::Dynamic> gram_m = (*(dt->A)).transpose() * (*(dt->A));
			//in trivial, A is symmetric, so nxn
			if (grad) {
				for(int d = 0; d < n; ++d){
					double g1 = 0, g2 = 0;
					for(int k = 0; k < n; ++k){
						g1+=z[k]*gram_m(d,k);
						g2+=(*(dt->A))(k,d);
					}
					std::cerr<<"eq_grad="<<2*(g1+(*(dt->Q))[d]*g2);
					grad[d]=2*(g1+(*(dt->Q))[d]*g2);
				}throw;
			}
			return (x.transpose()*x)(0,0);
		}

	Eigen::Vector<qreal, Eigen::Dynamic> AqcPqcAccelerator::_optimize_trivially(PauliHamiltonian *h, Eigen::Vector<qreal, Eigen::Dynamic> *Q, Eigen::Matrix<qreal, Eigen::Dynamic, Eigen::Dynamic> *A, std::vector<std::shared_ptr<Parameter>> *parameters){

		int opt_dim = Q->rows();
		//nlopt_opt opt = nlopt_create(NLOPT_LN_COBYLA, opt_dim);
		//nlopt_opt opt = nlopt_create(NLOPT_LD_SLSQP, opt_dim);
<<<<<<< HEAD
		nlopt_opt opt = nlopt_create(NLOPT_LD_TNEWTON_PRECOND_RESTART, opt_dim);

		OptData_trivial data {Q, A};

		//std::cerr<<"A: " << *A << "\n" << "q: " << -(*Q)<<std::endl;throw;

	    ConstrData_trivial constr_data {parameters, this, h, &data};
=======
		OptData data {Q, A, 0};

		//std::cerr<<"A: " << *A << "\n" << "q: " << -(*Q)<<std::endl;throw;

	    ConstrData constr_data {parameters, this, h, &data, options.printEpsilons, 0};
>>>>>>> main
		//nlopt_add_equality_constraint(opt, eq_constraint, &constr_data, 0);
		nlopt_add_inequality_constraint(opt, ineq_constraint_trivial, &constr_data, options.catol);
		double* lb = (double*) malloc(opt_dim * sizeof(double));
		double* ub = (double*) malloc(opt_dim * sizeof(double));
		for(int i = 0; i < opt_dim; ++i){
			lb[i] = -HUGE_VAL;ub[i]=-lb[i];
		}
		nlopt_set_lower_bounds(opt, lb);
		nlopt_set_upper_bounds(opt, ub);
		nlopt_set_min_objective(opt, lin_system_f_trivial, &data);
		//nlopt_set_ftol_rel(opt, options.xtol);
		//nlopt_set_ftol_abs(opt, options.xtol);

		nlopt_set_xtol_rel(opt, options.xtol);
		nlopt_set_xtol_abs1(opt, options.xtol);

		//nlopt_set_maxtime(opt, options.time_limit_step);
		nlopt_set_maxeval(opt, options.eval_limit_step);

		double *eps = (double*) malloc(opt_dim * sizeof(double));
		for(int i = 0; i < opt_dim; ++i)
			eps[i] = 0;
		double minf;
		nlopt_result opt_res = nlopt_optimize(opt, eps, &minf);
		if (opt_res < 0) {
			std::cerr<<"nlopt failed! error code: "<< opt_res << " = " << nlopt_result_to_string(opt_res) << " #:" << data.num_steps << std::endl;
		}
		else {
			std::cerr<<"nlopt success code: "<< opt_res << " = " << nlopt_result_to_string(opt_res) << " #:" << data.num_steps << std::endl;
			 //std::cerr<<"found minimum at f("<<eps[0];
			 //for(int i = 1; i < opt_dim; ++i)
			//	 std::cerr<<","<<eps[i];
			 //std::cerr<< ")= "<<minf<<"\n";

			if(options.printEpsilons)
				std::cerr<<"Constraint: " << constr_data.outConstraint << std::endl;

			Eigen::Vector<qreal, Eigen::Dynamic> eps_vect(opt_dim);
			for(int i = 0; i < opt_dim; ++i)
				eps_vect(i)=eps[i];

			//std::cerr<<eps_vect<<std::endl;
			//std::cerr<<"A_null:"<<A_null_space;

			free(eps);
			free(lb);free(ub);
			nlopt_destroy(opt);
			return eps_vect;

			//std::cerr<<res_eps;//throw;

			//std::cerr<<"x"<<A*res_eps-Q<<std::endl;
		}


	}

}
